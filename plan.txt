# Updated plan.txt

ðŸ“Œ Project Overview & Structure:
- Project Name: Hypertoroidal L-System Networks
- Core Concept: Networks of interconnected toroidal arrays with growth and connectivity determined by L-system rules
- Files Structure:
  hypertoroidal_lsystem_network/
  â”œâ”€â”€ torus.py               (already implemented [previous project, may need adjustment to align])
  â”œâ”€â”€ network_generator.py   (L-system based generation)
  â”œâ”€â”€ pathway.py             (inter-toroid connections)
  â”œâ”€â”€ junction.py            (toroid intersections)
  â”œâ”€â”€ network.py             (primary container & manager)
  â”œâ”€â”€ visualize.py           (network representation)
  â””â”€â”€ maze_solver_example.py (demonstration scenario)

Key Implementation Strategies:
1. Bottom-up construction: pathways â†’ junctions â†’ network
2. Flexible dimensionality in all components
3. Stochastic, parameter-driven network generation
4. Clear separations between generation, structure, and dynamics
5. Support for input/output nodes and loop structures

Development Phases:
1. Core structures (pathways, junctions)
2. Network management
3. L-system based generation with extended functionality
4. Visualization
5. Example scenario

ðŸ”¹ network_generator.py:

1. `Symbol(Enum)`:
   - Values: CREATE_TORUS, CONNECT_TOROIDS, START_BRANCH, END_BRANCH, TRANSFORM, INPUT, OUTPUT
   - Each symbol will have an associated integer parameter for variation

2. `Rule`:
   - `predecessor: Symbol`
   - `successor: List[Symbol]`
   - `probability: float`
   - `direction: Optional[str]`  # For loop functionality

3. `NetworkGeneratorConfig`:
   - `max_depth: int`
   - `balance_factor: float`
   - `branching_factor: int`
   - `create_torus_weights: List[float]`
   - `connect_toroids_weights: List[float]`
   - `allow_loops: bool`
   - `max_loop_depth: int`
   - `max_inputs: int`
   - `max_outputs: int`

4. `NetworkGenerator`:
   - `rules: Dict[Symbol, List[Rule]]`
   - `axiom: List[Symbol]`
   - `config: NetworkGeneratorConfig`
   - `generate(iterations: int) -> List[Symbol]`
   - `prune_network(sequence: List[Symbol]) -> List[Symbol]`
   - Uses NumPy for random selection based on probabilities

ðŸ”¹ pathway.py:

1. `TransferFunction(Protocol)`:
   - `__call__(data: np.ndarray) -> np.ndarray`

2. `Pathway`:
   - `source: Tuple[Torus, Tuple[slice, ...]]`
   - `target: Tuple[Torus, Tuple[slice, ...]]`
   - `transfer_fn: TransferFunction`
   - `direction: Optional[str]`  # For loop functionality
   - `update() -> None`: Applies transfer_fn and updates target
   - Allow broadcasting in slice mappings

ðŸ”¹ junction.py:

1. `Junction`:
   - `inputs: List[Tuple[Torus, Tuple[slice, ...]]]`
   - `output: Tuple[Torus, Tuple[slice, ...]]`
   - `operation: Callable[[List[np.ndarray]], np.ndarray]`
   - `update() -> None`: Gathers inputs, applies operation, sets output

ðŸ”¹ network.py:

1. `Network`:
   - `toroids: Dict[int, Torus]`  # int is unique identifier
   - `pathways: List[Pathway]`
   - `junctions: List[Junction]`
   - `inputs: List[Tuple[int, Tuple[slice, ...]]]`  # Torus ID and slice
   - `outputs: List[Tuple[int, Tuple[slice, ...]]]`  # Torus ID and slice
   - `tick() -> None`: Updates all pathways and junctions
   - `inject_data(torus_id: int, data: np.ndarray, location: Tuple[slice, ...]) -> None`
   - `read_data(torus_id: int, location: Tuple[slice, ...]) -> np.ndarray`
   - `create_from_generator(generator: NetworkGenerator) -> None`

ðŸ”¹ visualize.py:
1. `TextNetworkVisualizer`:
   - Renders ASCII diagram of network
   - Shows toroids as [T1], [T2], etc
   - Pathways as arrows: â†’
   - Junctions as asterisks: *
   - Inputs as [I] and Outputs as [O]
   - `visualize(network: Network) -> str`
   - Uses `textwrap` for formatting
   - Sample output:
     ```
     [I] â†’ [T1] â†’ [T2]
            â†“     â†“
     [T3] * [T4] â†’ [O]
     ```
2. Future extension placeholder: `GraphNetworkVisualizer` using networkx/matplotlib

ðŸ”¹ Math & Architecture Decisions:
1. All data transfer preserves dimensionality
2. Use LCM (Least Common Multiple) for size matching, like in Torus arithmetic
3. Support n-dimensional toroids and transfers
4. Arithmetic operations (+, *, etc) as default transfer functions
5. Junctions support element-wise and reduction operations (sum, mean, min, max)
6. L-system uses stochastic context-free grammar with support for loops

ðŸ”¹ maze_solver_example.py:
- Create 2D toroidal maze representation
- Information "floods" through open pathways
- Use sigmoid transfer function to create "pressure" mechanic
- Junction max operation finds optimal paths
- Demonstrate use of INPUT and OUTPUT nodes

ðŸ”¹ Implementation Order:
1. Update NetworkGenerator (including new symbols and loop functionality)
2. Modify Pathway to support directional connections
3. Update Junction to handle potential loops
4. Enhance Network to interpret extended L-system output
5. Update visualization to include new symbols and connections

ðŸ”¹ Data Types:
- All numeric data: np.float32
- All indices: np.int32
- Boolean masks: np.bool_

ðŸ”¹ Performance Considerations:
- Use `np.vectorize` for transfer functions when possible
- Employ `np.einsum` for complex slice mappings
- Pre-allocate arrays in junctions and pathways

ðŸ”¹ Extensibility Hooks:
1. Custom Symbol subclasses
2. Pluggable TransferFunction protocol
3. Network to accept custom tick logic

Error handling strategy:
- Type checks using runtime_checkable protocols
- Value range validations
- Clear error messages with context

Testing strategy:
- Property-based testing for L-system generation
- Edge case unit tests for Pathway and Junction
- Integration tests on small networks
- Performance benchmarks
- Specific tests for loop functionality and INPUT/OUTPUT nodes


------------------------


So far we've:
1. Implemented our L-System based Network Generator as a tree-structured, recursion-driven, genuinely-branching L-System.
2. Added a degree of error-resilience, particularly around recursion.
3. Introduced a configuration object (NetworkGeneratorConfig) which allows:
   â€¢ Control over network complexity (max_depth)
   â€¢ Control over network topology (balance_factor, branching_factor)
   â€¢ Rule weighting (create_torus_weights, connect_toroids_weights)
   â€¢ Deterministic output (seed)
4. Implemented auto-normalization for our rule weights (// which maintains error-tolerance while preventing undefined behavior)
5. Implemented a general tracer (render_sequence) which provides a text-based, human-readable output of our network "recipe"

Key output: Our network generator produces a "recipe" â€” a executable, branching, reproducible description of a toroidal network â€” NOT the network itself.

Key interface details:
â€¢ Our "recipe" consists of Lists of Symbols/Lists[Symbols]  // where each Symbol carries a quantitative parameter
â€¢ config = NetworkGeneratorConfig(params...) provides complete runtime configuration
â€¢ generate() provides the recipe   // no parameters required; uses config
â€¢ Rules are stochastic & weighted, but can be made deterministic via seed

Critical for next phase:
â€¢ The Pathway, Junction, and Network implementations will need to interpret & instantiate our "recipe"
â€¢ We have five instruction types (Symbol VALUES) which they'll need to implement:
   CREATE_TORUS  // which requires creating a new Torus object
   CONNECT_TOROIDS  // which requires creating a new Pathway between two Tori
   TRANSFORM  // which requires mutating an existing Torus
   START_BRANCH, END_BRANCH   // which require parallel execution of a sequence

Next steps:
1. Implement Pathway  // which defines how two Tori interact
2. Implement Junction  // which defines how multiple Tori can have a shared interaction-point
3. Implement Network  // which interprets our recipe, instantiates Tori, Pathways, and Junctions, and manages information flow & evolution